## 浏览器渲染机制

不同的浏览器内核不同，渲染过程中有的细节也不一样，以`webkit`主流程为例：

![浏览器解析渲染机制](https://tva1.sinaimg.cn/large/007S8ZIlly1ghxofb9nf2j30hc0813zc.jpg)

### 浏览器解析渲染页面大致过程：

1、`DOM Tree`：浏览器向服务器发送`http`请求，服务器响应`http`请求并发送文档给浏览器，**浏览器解析`HTML`构建`DOM`树。**

> 其中HTML Parser就起到了将HTML标记解析成DOM Tree的作用，HTML Parser将文本的HTML文档，提炼出关键信息，嵌套层级的树形结构，便于计算拓展；这其中也有很多的规则和操作，比如容错机制，识别特殊标签`<br></br>`等

2、`CSSOM`：**浏览器解析`CSS`构建`CSSOM`树。**

> CSS Parser将很多个CSS文件中的样式合并解析出具有树形结构Style Rules，也叫做CSSOM
>
> 其中还有一个细节是浏览器解析文档：当遇到`<script>`标签的时候会停止解析文档，立即解析脚本，将脚本中改变DOM和CSS的地方分别解析出来，追加到DOM Tree和CSSOM上

3、`Render Tree`：**把`DOM`树和`CSSOM`树组合构建渲染树`Rander Tree`**，有了渲染树，浏览器就知道网页上有哪些节点以及每个节点的`CSS`属性。

> Render Tree的构建其实就是DOM Tree和CSSOM Attach的过程，在webkit中，解析样式和创建呈现器的过程称为"附加"，每个DOM节点都有一个"attach"方法，Render Tree其实就相当于一个计算好样式，与HTML对应的Tree

4、`Layout`：**根据`Render`树进行布局渲染`render layer`**，计算每个节点的几何结构（也就是计算出每个节点在屏幕上的位置）。

> 创建渲染树后，Layout根据根据渲染树中渲染对象的信息，计算好每一个渲染对象的位置和尺寸，将其放在浏览器窗口的正确位置，某些时候会在文档布局完成之后进行DOM修改，**重新布局的过程就称为回流**

5、`Painting`：将计算好的每个节点的布局信息绘制到屏幕上。

> 绘制阶段则会遍历呈现树，并调用呈现器的paint方法，将呈现器的内容显示在屏幕上，绘制的顺序其实就是元素进入堆栈样式上下文的顺序，例如，块呈现器的堆栈顺序如下：1.背景颜色，2.背景图片，3.边框，4.子代，5.轮廓

## 重绘和回流/重排

### 概念

重绘：**样式发生改变，位置没有发生变动**，页面不需要重新计算一次，重绘一次即可。

回流：**位置发生了变化影响了其他元素的位置**，需要重新计算位置即回流/重排，之后重绘。

> 重绘不一定回流，但回流必定重绘

### 重绘和回流的区别

- 回流指当前窗口发生改变，发生滚动操作，或者元素的位置大小相关属性被更新时会触发布局过程，**发生在render树**，比如元素的几何尺寸变化，就需要重新验证并计算Render Tree
- 重绘指当前视觉样式属性被更新时触发的绘制过程，**发生在渲染层render layer**
- 回流的成本比重绘高

### 重绘和回流的应用

#### 回流(`Reflow`)

* 增加、删除、更新`DOM`节点
* 通过`display: none`隐藏一个`DOM`节点（位置发生改变）
* 元素尺寸发生变化（如边距）
* 让一个`DOM`节点动画时
* 添加样式，让整个样式发生改变
* 改变窗口尺寸和滚动窗口
* **`计算offsetWidth、scrollTop、clientTop、getComputedStyle()等属性`**（获取这些属性的信息时需要返回新的布局信息，会强制队列刷新，触发回流）

#### 重绘(`Repaint`)

* 通过`visibility: hidden`隐藏一个节点需要重绘

### 减少回流重绘次数的方法

- 避免一条一条的修改DOM样式，而是修改className或者style.classText
- 对元素进行一个复杂的操作，可以先隐藏它，操作完成后在显示
- 在需要经常获取那些引起浏览器回流的属性值时，要缓存到变量中
- 不使用table布局，一个小的改动可能就会引起整个table重新布局
- 在内存中多次操作节点，完成后在添加到文档中

## 白屏

> 页面没有加载完，就会出现白屏。

* 对IE来说，**把样式放在底部时**，在某些场景下（如打开新窗口／刷新页面等）页面会出现白屏，而不是内容逐步展现。
* 如果**使用@import标签**，即使将CSS写入外部样式表由link引入并放在头部，也可能出现白屏。
* 把**js文件放入页面顶部而未使用defer或async延迟或异步加载js文件**，从而阻塞html与css的加载也会导致白屏。

## FOUC

> (Flash of unsettled content)无样式内容闪烁。 页面出现FOUC现象，具体表现为逐步加载无样式的内容，等CSS加载完成后页面突然展现样式。

把样式放在底部时，会先显示已加载的html内容，再逐步加载无样式内容，等css全部加载完成后页面突然展现样式。

## CSS 和 JS 最佳放置顺序

- **使用 link 标签**将样式表放在顶部
- 将**JS放在底部**

##### JS的阻塞问题

- JS会阻塞DOM树的解析和渲染
- 若JS位于页面顶部
  - JS脚本会阻塞后面内容的呈现
  - JS脚本会阻塞其后组件（如图片）的下载
  - JS加载时间过长，css需等待，则会出现一段时间**白屏**

##### CSS的阻塞问题

- **CSS会阻塞DOM树的渲染** （渲染树是依赖于CSSOM和DOM的，必须要等到CSSOM构建完成才能开始渲染）
- **CSS可能会阻塞DOM树的解析**（若CSS阻塞JS语句，JS会阻塞DOM，则CSS可能阻塞DOM）
- **CSS会阻塞其后面JS语句的执行**（JS可能会用到DOM节点和CSS样式）
- **是一种优化机制避免回流**

## 异步加载

```js
<script src="script.js"></script>
```

放在顶部的这个js文件，会提前加载，如何使它在顶部仍然稍后加载?

### async （异步脚本）

> 不让页面等待脚本下载和执行，从而异步加载页面其他内容（并行），异步脚本会在页面的load事件前执行。**不保证顺序**。

```js
<script async src="script.js"></script>

```

### defer（延迟脚本）

> js脚本会被延迟到整个页面都解析完成后再运行，会先于DOMContentLoaded事件执行。**按顺序执行**。

```js
<script defer src="script.js"></script>
```

**作用**：缩短了网页的加载时间，且他们的显示速度更快

## 页面加载

对于浏览器来说，页面加载主要有两个事件。`DOMContentLoaded、onLoad`。

### onLoad

> 等待页面所有`资源加载完成`才会触发。

### DOMContentLoaded

> 等页面`内容解析`完就触发。

- 若js在css前，则DOMContentLoaded不会等待css加载，也不会等待之后的图片、视频等其他资源加载。
- 若js在css后，CSS阻塞其后面的js语句执行，js阻塞DOM解析，就导致DOMContentLoaded会等待CSS加载完执行。

## 浏览器内核的理解

浏览器主要分成两部分：渲染引擎(layout engineer 或 Rendering Engine)和 JS 引擎。

**渲染引擎（浏览器内核）**：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后渲染到用户的屏幕上。**渲染引擎是浏览器兼容性问题出现的根本原因。**

**JS 引擎**：解析和执行 javascript 来实现逻辑和控制 DOM 进行交互。浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时会逐行解释每一句源码（转换为机器语言），然后由计算机去执行。所以 JavaScript 语言归为脚本语言，会逐行解释执行。

最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，**浏览器内核就倾向于只指渲染引擎**。

## 主流浏览器机器内核

| 浏览器  | 内核           | 备注                                                         |
| ------- | -------------- | ------------------------------------------------------------ |
| IE      | Trident        | IE、猎豹安全、360 极速浏览器、百度浏览器                     |
| firefox | Gecko          |                                                              |
| Safari  | webkit         | 从 Safari 推出之时起，它的渲染引擎就是 Webkit，一提到 webkit，首先想到的便是 chrome，Webkit 的鼻祖其实是 Safari。 |
| chrome  | Chromium/Blink | 在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。大部分国产浏览器最新版都采用 Blink 内核。二次开发 |
| Opera   | blink          | Opera 内核原为：Presto，现在跟随 chrome 用 blink 内核。      |




## 浏览器内核线程

> JS是单线程的。浏览器是允许多个线程异步执行的，除了JS引擎线程外还有GUI渲染线程、事件触发线程、HTTP请求线程、定时触发线程、下载线程等；其中，JS引擎线程、事件触发线程、GUI渲染线程属于常驻线程。

简单来说浏览器内核是通过取得页面内容、整理信息（应用 CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。

浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：

- GUI 渲染线程
- JavaScript 引擎线程
- 定时触发器线程
- 事件触发线程
- 异步 http 请求线程

#### 1.GUI 渲染线程

- 主要负责页面的渲染，解析 HTML、CSS，构建 DOM 树，布局和绘制等。
- 当界面需要重绘或者由于某种操作引发回流时，将执行该线程。
- 该线程与 JS 引擎线程互斥，当执行 JS 引擎线程时，GUI 渲染会被挂起，当任务队列空闲时，主线程才会去执行 GUI 渲染。

#### 2.JS 引擎线程

- 该线程当然是主要负责处理 JavaScript 脚本，执行代码。
- 也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS 引擎线程的执行。
- 当然，该线程与 GUI 渲染线程互斥，当 JS 引擎线程执行 JavaScript 脚本时间过长，将导致页面渲染的阻塞。

#### 3.定时器触发线程

- 负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。
- 主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待 JS 引擎线程执行。

#### 4.事件触发线程

- 主要负责将准备好的事件交给 JS 引擎线程执行。

比如 setTimeout 定时器计数结束， ajax 等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS 引擎线程的执行。

#### 5.异步 http 请求线程

- 负责执行异步请求一类的函数的线程，如： Promise，axios，ajax 等。
- 主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待 JS 引擎线程执行。

## 访问刷新分析

我们将访问和刷新分为以下三种情况：

- 标签进入、输入url回车进入
- 按刷新按钮、F5 刷新、网页右键“重新加载”
- ctrl + F5 强制刷新

假设当前有这么一个 index 页面，返回的响应信息如下：

```http
cache-control: max-age=72000
expires: Tue, 20 Nov 2018 20:41:14 GMT
last-modified: Tue, 20 Nov 2018 00:41:14 GMT
```

##### 1、标签进入、输入url回车进入

这种情况下会根据实际设计的缓存策略去判断。

1. 由于该例没有设置 `no-cache` 和 `no-store`，所以默认先走强缓存路线。根据 `cache-control` （`expires` 优先级低）判断缓存是否过期，若没有过期则此时返回 `200(from cache)`。
2. 若本地缓存已经过期再走协商缓存路线，根据之前的 `last-modified` 值去与服务器比对，若这个时间之后没有改过则去读取本地缓存，返回 `304(not modified)`。
3. 否则返回新的资源，状态码 `200(ok)`，并更新返回响应的 `last-modified` 值。

##### 2、按刷新按钮、F5 刷新、网页右键“重新加载”

这种情况下，实际是浏览器将 `cache-control` 的 `max-age` 直接设置成了 0，让缓存立即过期，直接走协商缓存路线。发送的请求头如下：

```http
cache-control: max-age=0
if-modified-since: Tue, 20 Nov 2018 00:41:14 GMT
```

##### 3、ctrl + F5 强制刷新

强制刷新的情况下，浏览器会强行设置 `no-cache`，强制获取最新的资源，就连 `if-modified-since` 等其他缓存协议字段都会被吃掉。此时发送的请求头如下：

```http
cache-control: no-cache
pragma: no-cache
```





