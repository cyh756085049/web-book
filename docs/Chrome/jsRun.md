## 变量提升

> JavaScript代码是按顺序执行的吗？

1. 在执行过程中，若使用了未声明的变量，那么 JavaScript 执行会报错。

2. 在一个变量定义之前使用它，不会出错，但是该变量的值会为 undefined，而不是定义时的值。
3. 3. 在一个函数定义之前使用它，不会出错，且函数能正确执行。

### 变量提升

定义：是指在 JavaScript 代码执行过程中，**JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头**。变量被提升后，会给变量设置默认值即`undefined`。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glgvpm99pcj30v80eq45o.jpg" alt="变量、函数提升示意图" style="zoom:50%;" />

### JavaScript 代码的执行流程

**变量提升实际上是变量和函数声明在代码里的位置是不会改变的，而是在编译阶段被 JavaScript 引擎放入内存中。**一段JavaScript 代码在执行之前需要被 JavaScript 引擎编译，编译完成之后，才会进入执行阶段。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glgx5ctg43j30wo05cwgh.jpg" alt="JavaScript的执行流程图" style="zoom:50%;" />

#### 1. 编译阶段

输入一段代码，经过编译后，会生成两部分内容：**执行上下文（Execution context）和可执行代码。**

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glgx843m2ej30uc0gan6e.jpg" alt="JavaScript执行流程细化图" style="zoom:50%;" />

**执行上下文是 JavaScript 执行一段代码时的运行环境**，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。

**在执行上下文中存在一个变量环境的对象（Viriable Environment）**，**该对象中保存了变量提升的内容**，比如上面代码中的变量myname 和函数 showName，都保存在该对象中。

#### 2. 执行阶段

有了执行上下文和可执行代码后，JavaScript 引擎开始执行“可执行代码”，按照顺序一行一行地执行。

!> 一段代码如果定义了两个相同名字的函数，那么最终生效的是最后一个函数。

### 总结

* JavaScript 代码执行过程中，需要先做**变量提升**，而之所以需要实现变量提升，是因为JavaScript **代码在执行之前需要先编译**。
* **在编译阶段，变量和函数会被存放到变量环境中**，变量的默认值会被设置为undefined；在代码执行阶段，JavaScript 引擎会从变量环境中去查找自定义的变量和函数。
* 如果在编译阶段，**存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个**，这是因为后定义的会覆盖掉之前定义的。

## 调用栈

> 为什么JavaScript代码会出现栈溢出？

在**执行之前就进行编译并创建执行上下文的代码**一般有以下三种情况：

1. 当 JavaScript **执行全局代码**的时候，**会编译全局代码并创建全局执行上下文**，而且在整个页面的生存周期内，全局执行上下文**只有一份**。

2. 当**调用一个函数的时候**，函数体内的代码会被**编译**，并**创建函数执行上下文**，一般情况下，**函数执行结束**之后，创建的**函数执行上下文会被销毁**。
3. 当使用 **eval 函数**的时候，eval 的代码也会被编译，并**创建执行上下文**。

在我们进行JavaScript编码时，有时候会遇到栈溢出的错误，此时就会涉及到调用栈的内容。在JavaScript 中有很多函数，经常会出现在一个函数中调用另外一个函数的情况，**调用栈就是用来管理函数调用关系的一种数据结构。**

### JavaScript的调用栈

JavaScript 引擎正是利用栈的这种结构来管理执行上下文的。**在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中**，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。

在代码的执行过程中，首先会创建全局上下文，包含定义的变量和创建的函数，并将其压入栈底，全局执行上下文压入到调用栈后，JavaScript 引擎便开始执行全局代码了。当遇到全局变量赋值操作时，将全局变量的undefined修改为对应的值，当调用函数时，首先JavaScript引擎会编译该函数，并为其创建一个函数执行上下文，并将其压入栈中，然后进入函数代码执行阶段，遇到赋值操作，直接赋值，遇到调用函数语句时，再次为其创建函数执行上下文，压入栈进行操作，当此函数返回时，该函数的执行上下文就会从栈顶弹出，并将返回值返回，将其函数执行上下文从栈顶弹出，此时调用栈中只剩下全局上下文了。

#### 1、利用浏览器查看调用栈的信息

打开“开发者工具”，点击“Source”标签，选择 JavaScript 代码的页面，然后在代码行加上断点，并刷新页面。你可以看到执行到 add 函数时，执行流程就暂停了，这时可以通过右边“callstack”来查看当前的调用栈的情况，如下图：

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glhxmk1zznj30ug0gu7ax.jpg" alt="函数调用关系" style="zoom:50%;" />

从图中可以看出，右边的“call stack”下面显示出来了函数的调用关系：**栈的最底部是anonymous，也就是全局的函数入口**；中间是 addAll 函数；顶部是 add 函数。这就清晰地反映了函数的调用关系，所以在分析复杂结构代码，或者检查 Bug 时，调用栈都是非常有用的。

除了通过断点来查看调用栈，你还**可以使用 `console.trace() `来输出当前的函数调用关系**，比如在示例代码中的 add 函数里面加上了 console.trace()，你就可以看到控制台输出的结果，如下图：

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glhxpsnq9xj30tm0m444u.jpg" alt="" style="zoom:50%;" />

#### 2. 栈溢出（Stack Overflow）

**调用栈是有大小的，当入栈的执行上下文超过一定数目**，JavaScript 引擎就会报错，我们把这种错误叫做**栈溢出**。

递归代码就很容易出现栈溢出的情况，如下代码：

```js
function division(a,b){    
  return division(a,b);
}
console.log(division(1,2));
```

当执行时，就会报错栈溢出，如下图：

![栈溢出](https://tva1.sinaimg.cn/large/0081Kckwly1glhxuj2r87j31a80fadjn.jpg)

因为当 JavaScript 引擎开始执行这段代码时，它首先调用函数 division，并创建执行上下文，压入栈中；然而，**这个函数是递归的，并且没有任何终止条件**，所以它会一直创建新的函数执行上下文，并反复将其压入栈中，但**栈是有容量限制的**，超过最大数量后就会出现栈溢出的错误。

理解了栈溢出原因后，我们就可以使用一些方法来避免或者解决栈溢出的问题，比如把递归调用的形式改造成其他形式，或者使用加入定时器的方法来把当前任务拆分为其他很多小任务。

### 总结

每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。

如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。

当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。

当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。

