## Chrome架构

> 仅仅打开一个页面，为什么有4个进程？

### 进程和线程

进程：一个进程就是一个程序的运行实例。

> 启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。

线程：是依附于进程的，而进程中使用多线程并行处理能提升运算效率。

进程和线程之间的关系：

* 进程中的任意一线程执行出错，都会导致整个进程的崩溃。
* 线程之间共享进程中的数据。
* 当一个进程关闭之后，操作系统会回收进程所占用的内存。
* 进程之间的内容相互隔离。

> 多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。

### 单进程浏览器时代

**单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里**，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glcy7vh8puj30yq0icwmj.jpg" alt="单进程浏览器架构图" style="zoom:50%;" />

#### 导致的问题

* **不稳定**：早期浏览器需借助**插件**来实现诸如 Web 视频、Web 游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，一个插件的意外崩溃会引起整个浏览器的崩溃。除了插件之外，**渲染引擎模块**也是不稳定的，通常一些复杂的 JavaScript 代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃。
* **不流畅**：当一个**无限循环的脚本**运行在一个单线程浏览器页面中，当其执行时，会独占整个线程，导致其他运行在该线程中的模块就没有机会被执行。这样就会导致整个浏览器失去响应，变卡顿。**页面的内存泄漏**也会导致单进程变慢，通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。

* **不安全**：在页面中运行一个**恶意插件**时，会引发安全性问题，**页面脚本**也可以通过浏览器的漏洞来获取系统权限，然后对电脑做一些恶意的事情，引发安全问题。

### 多进程浏览器时代

#### 早期多进程架构

2008 年 Chrome 发布时的进程架构如下，Chrome 的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过 IPC 机制进行通信（图中虚线部分）。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glcyiw2o28j30z60pyk2a.jpg" alt="早期Chrome进程架构图" style="zoom:50%;" />

#### 解决单进程浏览器时代问题

* **稳定性**：**进程相互隔离**，当一个页面或者插件崩溃时，只会影响当前的页面进程或者插件进程，不会影响到浏览器和其他页面。
* **流畅性**：JavaScript 也是运行在渲染进程中的，即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为**其他页面的脚本是运行在它们自己的渲染进程中的**。所以当在 Chrome 中运行死循环脚本时，没有响应的仅仅是当前的页面。**对于内存泄漏**，当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。

* **安全性**：采用多进程架构的额外好处是可以使用**安全沙箱**，可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。**Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。**

### 目前多进程架构

最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glcyved3mbj30yi0i2dl7.jpg" alt="最新的Chrome进程架构图" style="zoom:50%;" />

| 进程名称   | 功能描述                                                     |
| ---------- | ------------------------------------------------------------ |
| 浏览器进程 | 主要负责**界面显示，用户交互，子进程管理，同时提供存储等**功能 |
| 渲染进程   | 核心任务是**将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页**，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，**Chrome 会为每个 Tab 标签创建一个渲染进程**。出于安全考虑，**渲染进程都是运行在沙箱模式下** |
| GPU 进程   | Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了**实现 3D CSS 的效果**，只是随后**网页、Chrome 的 UI 界面都选择采用 GPU 来绘制**，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了GPU 进程 |
| 网络进程   | 主要负责**页面的网络资源加载**，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程 |
| 插件进程   | 主要是**负责插件的运行**，因插件易崩溃，所以需要通过插件进程来隔离，以**保证插件进程崩溃不会对浏览器和页面造成影响** |

> 插件为什么易崩溃？

!> 总结：打开一个页面，会有4个进程，分别是1 个网络进程、1 个浏览器进程、1 个 GPU 进程和1个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。

#### 出现的问题

* **更高的资源占用**。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。

* **更复杂的体系架构**。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。

### 未来面向服务的架构

为了解决这些问题，在 2016 年，Chrome 官方团队使用**“面向服务的架构”（ServicesOriented Architecture，简称SOA）**的思想设计了新的 Chrome 架构。原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，**通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统**，更好实现 Chrome 简单、稳定、高速、安全的目标。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glczcszgr5j31040l2ten.jpg" alt="面向服务的架构模型图" style="zoom:50%;" />

Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务。

Chrome 还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，但是如果在资源受限的设备上（如下图），Chrome 会将很多服务整合到一个进程中，从而节省内存占用。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glczf5crmqj31080mkn6a.jpg" style="zoom:50%;" />

## TCP协议

>  如何保证页面文件能被完整送达浏览器？

衡量Web页面性能的一个重要指标：`FP(First Paint)`，**指从页面加载到首次开始绘制的时长。**

影响`FP`的因素：网络加载速度。

> 优化 Web 页面的加载速度->充分的了解网络->了解网络协议->基于TCP/IP 的工作—>定位问题

在网络中，一个文件通常会被拆分为很多**数据包**来进行传输，而数据包在传输过程中又有很大概率丢失或者出错。那么**如何保证页面文件能被完整地送达浏览器呢**？

### 数据的传输过程

**互联网中的数据是通过数据包来传输的**。如果发送的数据很大，那么该数据就会被拆分为很多小数据包来传输。

#### 1. IP：把数据包送达目的主机

数据包要在互联网上进行传输，就要符合网际协议（Internet Protocol，简称IP）标准。互联网上不同的在线设备都有唯一的地址，计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。

> 如果要想把一个数据包从主机 A 发送给主机 B，那么在传输之前，数据包上会被附加上主机 B 的 IP 地址信息，这样在传输过程中才能正确寻址。额外地，数据包上还会附加上主机A 本身的 IP 地址，有了这些信息主机 B 才可以回复信息给主机 A。这些附加的信息会被装进一个叫 **IP 头**的数据结构里。**IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息。**

#### 2. UDP：把数据包送达应用程序

IP 是非常底层的协议，只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序，因此，需要基于 IP 之上开发能和应用打交道的协议，最常见的是**“用户数据包协议（User Datagram Protocol）”，简称UDP**。

UDP 中一个最重要的信息是**端口号**，端口号其实就是一个数字，每个想访问网络的程序都需要绑定一个端口号。通过端口号 UDP 就能把指定的数据包发送给指定的程序了，所以**IP通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序**。和 IP 头一样，**端口号会被装进 UDP 头里面**，UDP 头再和原始数据包合并组成新的UDP 数据包。**UDP 头中除了目的端口，还有源端口号等信息。**

在使用 UDP 发送数据时，有各种因素会导致数据包出错，虽然 UDP 可以校验数据是否正确，但是**对于错误的数据包，UDP 并不提供重发机制，只是丢弃当前的包**，而且 UDP 在发送之后也无法知道是否能达到目的地。虽然**UDP 不能保证数据可靠性，但是传输速度却非常快**，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。

#### 3. TCP：把数据完整地送达应用程序

对于浏览器请求，或者邮件这类要求数据传输可靠性（reliability）的应用，如果**使用 UDP来传输会存在两个问题**：

* 数据包在传输过程中**容易丢失**；
* 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 **UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件**。

基于这两个问题，引入 TCP 了。**TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议**。相对于 UDP，**TCP 有下面两个特点**:

* 对于数据包丢失的情况，**TCP 提供重传机制**；
* **TCP 引入了数据包排序机制**，用来保证把乱序的数据包组合成一个完整的文件。

和 UDP 头一样，**TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号**，以便接收端通过序号来重排数据包。

### 完整的 TCP 连接过程

一个完整的 TCP 连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gld2crerjhj30vy0e4q75.jpg" alt="一个TCP连接的生命周期" style="zoom:50%;" />

**建立连接阶段**。这个阶段是通过“**三次握手**”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。**面向连接是指在数据通信开始之前先做好两端之间的准备工作**。所谓三次握手，是指在建立一个 TCP 连接时，**客户端和服务器总共要发送三个数据包以确认连接的建立。**

**传输数据阶段**。在该阶段，**接收端需要对每个数据包进行确认操作**，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为**数据包丢失**，并触发发送端的**重发机制**。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 **TCP 头中的序号为其排序**，从而保证组成完整的数据。

**断开连接阶段**。数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“**四次挥手**”来保证双方都能断开连接。

### 总结

互联网中的数据是通过数据包来传输的，数据包在传输过程中容易丢失或出错。

IP 负责把数据包送达目的主机。

UDP 负责把数据包送达具体应用。

而 TCP 保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接。

## HTTP请求流程

> 为什么很多站点第二次打开速度会很快？

**HTTP 协议，正是建立在 TCP 连接基础之上的**。**HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础**，通常由浏览器发起请求，用来获取不同类型的文件，例如HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。此外，HTTP 也是浏览器使用最广的协议。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gld98uqgldj30zy0fsaft.jpg" alt="HTTP请求流程" style="zoom:50%;" />

### 浏览器端发起 HTTP 请求流程

#### 1. 构建请求

浏览器构建**请求行**信息`GET /index.html HTTP1.1`，构建完成，浏览器准备发起网络请求。

#### 2. 查找缓存

在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，**浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。**

（1）当浏览器发现请求的资源已经在浏览器缓存中**存有副本**，它会**拦截请求，返回该资源的副本，并直接结束请求**，而不会再去源服务器重新下载。这样做的好处有：缓解服务器端压力，提升性能（获取资源的耗时更短了）；对于网站来说，缓存是实现快速资源加载的重要组成部分。

（2）如果缓存查找失败，就会进入网络请求过程了。

#### 3. DNS解析(准备 IP 地址和端口)

浏览器使用**HTTP 协议作为应用层协议**，用来封装请求的文本信息；并使用**TCP/IP 作传输层协议**将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说**HTTP 的内容是通过 TCP 的传输数据阶段来实现的**。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gld324ft0hj30wk0kgafy.jpg" alt="TCP和HTTP关系" style="zoom:50%;" />

从图中可以看出，HTTP 网络请求的第一步是和服务器建立 TCP 连接。而建立TCP连接的第一步是需要准备IP地址和端口号。

> 根据我们输入的url地址，如何获取IP地址和端口号呢？

**域名系统，简称DNS（Domain Name System），是将域名映射为IP的系统，**负责把域名和 IP 地址做一一映射关系。

因此**浏览器首先会请求DNS返回域名对应的IP。**当然浏览器还提供了**DNS 数据缓存服务**，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。

#### 4. 等待 TCP 队列

当IP地址和端口号都准备好了之后，需要判断当前域名下的请求数量。Chrome 有个机制，**同一个域名同时最多只能建立 6 个 TCP 连接**，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。

#### 5. 建立 TCP 连接

排队等待结束之后，在 HTTP 工作开始之前，浏览器通过 TCP 与服务器建立连接。即三次握手。

#### 6. 发送 HTTP 请求

一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gld3ob07hpj30w40l617w.jpg" alt="HTTP请求数据格式" style="zoom:50%;" />

首先浏览器会向服务器发送请求行，它包括了**请求方法、请求 URI（Uniform ResourceIdentifier）和 HTTP 版本协议**。

> **发送请求行，就是告诉服务器浏览器需要什么资源**，最常用的请求方法是**Get**。另外一个常用的请求方法是**POST**，它用于发送一些数据给服务器，比如登录一个网站，就需要通过 POST 方法把用户信息发送给服务器。如果使用 POST 方法，那么浏览器还要准备数据给服务器，这里准备的数据是通过**请求体**来发送。

在浏览器发送请求行命令之后，还要**以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器**。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息等等。

### 服务器端处理 HTTP 请求流程

HTTP 的请求信息被送达了服务器后，服务器会根据浏览器的请求信息来准备相应的内容。

#### 1. 返回请求

一旦服务器处理结束，便可以返回数据给浏览器了。可以通过工具软件 curl 来查看返回请求数据：`curl -i https://xxx.cn`，返回结果如下：

> -i是为了返回响应行、响应头和响应体的数据

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gld4e3muebj30v80loalk.jpg" alt="服务器响应的数据格式" style="zoom:50%;" />

首先服务器会返回响应行，包括协议版本和状态码。但并不是所有的请求都可以被服务器处理，对于一些无法处理或者处理出错的信息，服务器会通过请求行的状态码来告诉浏览器它的处理结果，最常用的状态码是 200，表示处理成功；如果没有找到页面，则会返回404，还会出现403，500等状态码。

随后，服务器会随同响应向浏览器发送响应头。**响应头包含了服务器自身的一些信息**，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。

发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了 HTML 的实际内容。

#### 2. 断开连接

通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。

如果浏览器或者服务器在其头信息中加入了：**`Connection:Keep-Alive`，**那么 **TCP 连接在发送后将仍然保持打开状态**，这样浏览器就可以继续通过同一个 TCP 连接发送请求。**保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。**

#### 3. 重定向

当你在浏览器中打开geekbang.org 后，你会发现最终打开的页面地址是 https://www.geekbang.org。这两个 URL 之所以不一样，是因为涉及到了一个重定向操作。在控制台输入如下命令：`curl -I geekbang.org`，最终返回的数据如下图，响应行返回的状态码是 301，需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。

> -I表示只需要获取响应头和响应行数据，而不需要获取响应体的数据。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gld4y2x3pij30vo0j6qd8.jpg" alt="重定向格式" style="zoom:50%;" />

### 浏览器资源缓存

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gld8n3u7bhj30t80wi1b1.jpg" alt="缓存查找示意图" style="zoom:50%;" />

当服务器返回HTTP 响应头给浏览器时，**浏览器是通过响应头中的 `Cache-Control` 字段来设置是否缓存该资源**。通常，我们还**需要为这个资源设置一个缓存过期时长，而这个时长是通过 `Cache-Control` 中的 `Max-age` 参数来设置的**，比如上图设置的缓存过期时间是 2000 秒：`Cache-Control:Max-age=20`。

* 当该缓存资源还未过期， 如果再次请求该资源，会直接返回缓存中的资源给浏览器。
* 如果缓存过期了，浏览器则会继续发起网络请求，并且在HTTP 请求头中带上：`If-None-Match:"4f80f-13c-3a1xb1`，服务器收到请求头后，会根据 `If-None-Match` 的值来判断请求的资源是否有更新：
  * 如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了"。
  * 如果资源有更新，服务器就直接返回最新资源给浏览器。

### 问题

#### 1、为什么很多站点第二次打开速度会很快？

第一次加载页面过程中，缓存了一些耗时的数据。DNS 缓存和页面资源缓存这两块数据是会被浏览器缓存的。浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS 数据也被浏览器缓存了，这又省去了 DNS 查询环节。

#### 2. 登录状态是如何保持的？

> 总结：如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gld95bhek8j30xw0rsah7.jpg" alt="Cookie流程图" style="zoom:50%;" />

浏览器：用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用 POST 方法提交用户登录信息给服务器。

服务器：接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并**把该字符串写到响应头的 `Set-Cookie `字段里：`Set-Cookie: UID=3431uad;`，然后把响应头发送给浏览器**。

浏览器：在接收到服务器的响应头后，开始解析响应头，**如果遇到响应头里含有 Set-Cookie 字段的情况，浏览器就会把这个字段信息保存到本地**。比如把UID=3431uad保持到本地。

浏览器：当用户再次访问时，浏览器会发起 HTTP 请求，但**在发起请求之前，浏览器会读取之前保存的 Cookie 数据，并把数据写进请求头里的 Cookie 字段里：`Cookie: UID=3431uad;`**，然后浏览器再将请求头发送给服务器。

服务器：在收到 HTTP 请求头数据之后，就会**查找请求头里面的“Cookie”字段信息，当查找到包含UID=3431uad的信息**时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。

浏览器：在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了。

## 导航流程

> 从输入URL到页面展示，中间发生了什么？

1. 首先，用户从**浏览器进程里输入请求信息**；
2. 然后**网络进程发起URL请求**；
3. 服务器响应URL请求后，**浏览器进程开始准备渲染进程**；
4. 渲染进程准备好后，向**渲染进程提交页面数据，即提交文档阶段**；
5. **渲染进程**接收文档信息后，便开始**解析页面和加载子资源**，完成页面渲染。

!> 用户发出URL请求到页面开始解析的这个过程，叫做**导航**。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gle6zootl6j30xu0h0ajz.jpg" alt="从输入url到页面展示完整流程" style="zoom:50%;" />

整个流程中需要各个进程之间的配合，浏览器进程主要负责用户交互、子进程管理和文件存储等功能；网络进程主要面向渲染进程和浏览器进程等提供网络下载功能；渲染进程主要负责把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。

> 因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，就是为了保证系统的安全

### 从输入 URL 到页面展示详细流程

> * 服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断。
> * Chrome 默认采用每个标签对应一个渲染进程，但是如果两个页面属于同一站点，那这两个标签会使用同一个渲染进程。
> * 浏览器的导航过程涵盖了从用户发起请求到提交文档给渲染进程的中间所有阶段。

#### 1. 用户输入

用户首先在浏览器输入查询的信息，**地址栏会判断输入的信息是搜索内容还是请求的URL**。

* 如果是**搜索内容**，地址栏会使用浏览器默认的搜索引擎来合成新的带搜索内容的URL。
* 如果**输入内容符合URL规则**，地址栏会根据相应的规则把此内容加上协议合成完整的URL。

![image-20201206163123531](https://tva1.sinaimg.cn/large/0081Kckwly1gle7wzxjkjj31eq0amqdc.jpg)

当用户输入查询内容并回车后，浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时页面显示的依然是之前打开的页面内容，并没立即替换为新输入查询内容的页面。因为**需要等待提交文档阶段，页面内容才会被替换**。

#### 2. URL 请求过程

接下来，便进入了页面资源请求过程。这时，**浏览器进程会通过进程间通信（IPC）把 URL请求发送至网络进程**，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。

* 网络进程查询本地缓存是否有该资源，如有，直接返回，如没有，直接进入网络请求流程。
* 先对URL请求进行DNS解析，获取请求域名的服务器IP地址，如果请求协议是HTTPS，则需要建立TLS连接。
* 然后利用IP地址和服务器建立TCP连接，连接建立成功之后，浏览器端构建请求信息发送给服务端。
* 服务端收到请求信息后，会根据请求信息生成响应数据，发给网络进程。
* 网络进程接收到响应数据后，解析响应数据。

##### （1）重定向

在网络进程解析服务端发送的响应头时，如果发现返回的状态码是301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。

!> 在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。

##### （2）响应类型处理

URL 请求的数据类型，有时候是一个下载类型，有时候是正常的 HTML 页面，浏览器就需要通过`Content-Type`区分，**`Content-Type` 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型**，然后浏览器会根据 `Content-Type` 的值来决定如何显示响应体的内容。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gle8jhdykmj30uq0ecqbt.jpg" style="zoom:50%;" />

需要注意的是，如果服务器配置` Content-Type` 不正确，比如将 `text/html `类型配置成`application/octet-stream` 类型，那么浏览器可能会曲解文件内容，比如会将一个本来是用来展示的页面，变成了一个下载文件。

所以，不同 Content-Type 的后续处理流程也截然不同。**如果 `Content-Type `字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。但如果是HTML，那么浏览器则会继续进行导航流程。**由于 Chrome的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。

#### 3. 准备渲染进程

默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。

![image-20201206170531089](https://tva1.sinaimg.cn/large/0081Kckwly1gle8wi606pj31eg0m27gr.jpg)

从图中可以看出，打开的两个页面是运行在同一个渲染进程中的。

**那什么情况下多个页面会同时运行在一个渲染进程中呢？**

要解决这个问题，首先需要了解下什么是**同一站点（same-site）**。具体地讲，我们将“同一站点”定义为**根域名**（例如，geekbang.org）加上**协议**（例如，https:// 或者http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：

```js
https://time.geekbang.org
https://www.geekbang.org
https://www.geekbang.org:8080
```

它们都是属于**同一站点**，因为它们的协议都是 HTTPS，而且根域名也都是geekbang.org。

Chrome 的默认策略是，**每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。**

##### 总结

打开一个新页面采用的**渲染进程策略**就是：

* 通常情况下，打开新的页面都会使用单独的渲染进程；
* 如果从 A 页面打开 B 页面，且 A 和 B 都**属于同一站点**的话，那么 **B 页面复用 A 页面的渲染进程**；如果是**其他情况**，浏览器进程则会为 B **创建一个新的渲染进程**。

渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。

#### 4. 提交文档

> 这里的**“文档”是指 URL 请求的响应体数据**。

* “提交文档”的消息是由浏览器进程发出的，**渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”**。

* 等文档数据传输完成之后，**渲染进程会返回“确认提交”的消息给浏览器进程**。

* **浏览器进程**在收到“确认提交”的消息后，**会更新浏览器界面状态**，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。

这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。

此时，一个完整的导航流程结束，之后进入渲染阶段。

#### 5. 渲染阶段

一旦文档被提交，渲染进程便开始页面解析和子资源加载了。一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。至此，一个完整的页面就生成了。

## 渲染流程

> HTML、CSS和JavaScript，是如何变成页面的？

HTML、CSS和JavaScript的相关含义如下图：

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glf273whszj30w60ni0yj.jpg" alt="HTML、CSS和JavaScript关系图" style="zoom:50%;" />

HTML 的内容是由标记（标签）和文本组成；CSS 又称为层叠样式表，是由选择器和属性组成；JavaScript是使网页的内容“动”起来。

### 渲染机制

渲染模块在执行过程中会被划分为很多子阶段，输入的HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做**渲染流水线**，按照渲染的时间顺序，流水线可分为如下几个子阶段：**构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成**。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glfhhuzrqbj30x20psq9c.jpg" alt="渲染流水线示意图" style="zoom:50%;" />

1. 渲染进程将 **HTML 内容转换**为能够读懂的**DOM 树**结构。
2. 渲染引擎将 **CSS 样式表转化为浏览器可以理解styleSheets**，计算出 DOM 节点的样式。
3. 创建**布局树**，并计算元素的布局信息。
4. 对布局树进行**分层**，并生成分层树。
5. 为每个图层生成**绘制列表**，并将其提交到**合成线程**。
6. 合成线程将**图层分成图块**，并在**光栅化线程池中将图块转换成位图**。
7. 合成线程发送绘制图块命令**DrawQuad**给浏览器进程。
8. 浏览器进程**根据 DrawQuad 消息生成页面**，并显示到显示器上。

#### 构建 DOM 树

浏览器无法直接理解和使用 HTML，所以需要将HTML 转换为浏览器能够理解的结构-DOM 树。

![DOM树构建过程](https://tva1.sinaimg.cn/large/0081Kckwly1glf2f6rgm4j30wy0jcq8u.jpg)

从图中可以看出，**构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由HTML 解析器解析，最终输出树状结构的 DOM**。

在浏览器的开发者工具中打开控制台，输入`document`，会看到一个完整的DOM树结构，DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，**DOM 是保存在内存中树状结构**，**可以通过 JavaScript 来查询或修改其内容**。

#### 样式计算（Recalculate Style）

样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 **CSS 的继承和层叠**两个规则。这个阶段**最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内**。这个阶段大体可分为三步来完成。

##### 1. 把 CSS 转换为浏览器能够理解的结构

CSS 样式来源主要有三种：

* 通过 link 引用的外部 CSS 文件
* `<style>`标记内的 CSS
* 元素的 style 属性内嵌的 CSS

和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以**当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。**

在浏览器控制台中输入`document.styleSheets`，就可以查看其结构：

![](https://tva1.sinaimg.cn/large/0081Kckwly1glf2z40obgj31e40methc.jpg)

##### 2. 转换样式表中的属性值，使其标准化

在CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要**将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化**。

![标准化属性值](https://tva1.sinaimg.cn/large/0081Kckwly1glf31npkunj30vy0duqap.jpg)

##### 3. 计算出 DOM 树中每个节点的具体样式

**这就涉及到 CSS 的继承规则和层叠规则了**。CSS 继承就是每个 DOM 节点都包含有父节点的样式。如下示例：

```css
body { font-size: 20px }
p {color:blue;}
span  {display: none}
div {font-weight: bold;color:red}
div  p {color:green;}
```

此样式表最终应用到DOM节点和效果图如下：

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glf39p8emuj30uw0soajb.jpg" style="zoom:50%;" />

打开 Chrome 的“开发者工具”，选择第一个“element”标签，再选择“style”子标签，你会看到如下界面：

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glf3k0ih0kj30u00v9to3.jpg" alt="样式的继承过程界面" style="zoom:50%;" />

> **UserAgent 样式**，它是浏览器提供的一组默认样式，如果你不提供任何样式，默认使用的就是 UserAgent样式。

样式计算过程中的第二个规则是**样式层叠**。**层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法**。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。

如果想了解每个 DOM 元素**最终的计算样式**，可以打开 Chrome 的“开发者工具”，选择第一个“element”标签，然后再选择“Computed”子标签，红框中是标签的ComputedStyle 的值，如下图：

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffd5fcn1j31080todq6.jpg" alt="DOM元素最终计算的样式" style="zoom:50%;" />

#### 布局阶段（Layout）

有了DOM 树和 DOM 树中元素的样式，还不能显示页面，需要知道DOM元素的几何位置信息，计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。

Chrome 在布局阶段需要完成两个任务：**创建布局树和布局计算。**

##### 1. 创建布局树

在 DOM 树中还含有很多不可见的元素，比如 head 标签，还有使用了display:none 属性的元素。所以**在显示之前，我们还要额外地构建一棵只包含可见元素布局树**。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffqt27fgj30ub0u015t.jpg" alt="布局树构造过程示意图" style="zoom:50%;" />

从图中可以看出，DOM树种所有不可见的节点都没有包含到布局树中。

##### 2. 布局计算

计算布局树节点的坐标位置。

#### 分层（Layer）

对于页面的一些复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing做 z 轴排序等，为了更加方便地实现这些效果，**渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。**

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glfggskvzkj30y00nadls.jpg" alt="布局树和图层树的关系" style="zoom:50%;" />

通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。

那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。

* 第一点，拥有层叠上下文属性的元素会被提升为单独的一层。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glfgo6uq98j30vo0kuwgb.jpg" alt="层叠上下文示意图" style="zoom:50%;" />

​	明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的	元素等，都拥有层叠上下文属性。

* 第二点，需要剪裁（clip）的地方也会被创建为图层。

#### 图层绘制（Paint）

渲染引擎实现图层的绘制是会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。

#### 栅格化（raster）操作

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程，**合成线程会将图层划分为图块（tile）**。

然后**合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。**而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glfhb49w70j30xk0mo43n.jpg" alt="渲染进程" style="zoom:50%;" />



> **视口（ViewPort）**：屏幕上页面的可见区域
>
> 在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。
>
> 基于这个原因，**合成线程会将图层划分为图块（tile）**，这些图块的大小通常是 256x256或者 512x512。

通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glfhf5fjjsj30wy0s6gsj.jpg" alt="GPU栅格化" style="zoom:50%;" />

从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。

#### 合成（draw quad）和显示（display）

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“**DrawQuad**”，然后将该命令提交给浏览器进程。

浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。

### 重排、重绘和合成

#### 重排（更新了元素的几何属性）

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glfhndhyftj30v4092gp9.jpg" style="zoom:50%;" />

从上图可以看出，如果通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么**浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排**。而且，重排需要更新完整的渲染流水线，所以**开销也是最大的**。

#### 重绘（更新元素的绘制属性）

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glfk3mg3dkj30wq08u787.jpg" style="zoom:50%;" />

从图中可以看出，如果修改了元素的背景颜色，那么**布局阶段将不会被执行**，因为并没有引起几何位置的变换，所以就**直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘**。相较于重排操作，**重绘省去了布局和分层阶段**，所以**执行效率会比重排操作要高一些**。

#### 合成

如果**更改一个既不要布局也不要绘制的属性**，**渲染引擎将跳过布局和绘制，只执行后续的合成操作**，我们把这个过程叫做**合成**。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glfkb6d1i3j30x0088adp.jpg" style="zoom:50%;" />
在上图中，使用CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，**合成能大大提升绘制效率**。

