## 消息队列和事件循环

> 页面是怎么“活起来”的？

每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是消息队列和事件循环系统。

这篇文章从简单的场景分析，然后一步步了解浏览器页面主线程是如何运作的。

#### 使用单线程处理安排好的任务

比如要在一个线程中执行多个任务，我们需要将所有这些任务按顺序放进主线程中，等线程执行时，这些任务会按照顺序在线程中依次被执行，等所有任务执行完成之后，线程会自动退出。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm0czpkocwj30tq0bs0y8.jpg" style="zoom:50%;" />

#### 在线程运行过程中处理新任务

但并不是所有的任务都是在执行之前统一安排好的，大部分情况下，新的任务是在线程运行过程中产生的。比如在线程执行过程中，又接收到了一个新的任务要求，那上面那种方式就无法处理这种情况了。

要想在线程运行过程中，能接收并执行新的任务，就需要采用**事件循环机制**。我们可以通过一个 for 循环语句来监听是否有新任务。

相较于第一版的线程，这一版的线程做了两点改进。

* 引入了**循环机制**，具体实现方式是在线程语句最后添加了一个**for 循环语句**，线程会一直循环执行。
* 引入了**事件**，可以在线程运行过程中，等待用户输入信息，等待过程中线程处于暂停状态，一旦接收到用户输入的信息，那么线程会被激活，然后执行相应运算，最后输出结果。

通过引入事件循环机制，就可以让该线程“活”起来了，我们可以结合下图来参考下这个改进版的线程。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm0d15o3caj30su0hk425.jpg" style="zoom:50%;" />

#### 处理其他线程发送过来的任务

在上面的线程模型中，所有的任务都是来自于线程内部，如果另外一个线程想让主线程执行一个任务，利用第二版的线程模型是无法做到的。那下面就来看看其他线程是如何发送消息给渲染主线程的，具体形式参考下图：

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm0d79m5blj30s60iigq8.jpg" style="zoom:50%;" />

从上图可以看出，渲染主线程会频繁接收到来自于 IO 线程的一些任务，接收到这些任务之后，渲染进程就需要着手处理，比如接收到资源加载完成的消息后，渲染进程就要着手进行DOM 解析了；接收到鼠标点击的消息后，渲染主线程就要开始执行相应的 JavaScript 脚本来处理该点击事件。

如何设计好一个线程模型，能让其能够接收其他线程发送的消息呢？一个通用模式是使用**消息队列**。消息队列是一种数据结构，可以存放要执行的任务。它符合队列“**先进先出**”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。

有了队列之后，我们就可以继续改造线程模型了，改造方案如下图所示：

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm0dqe021oj30wo0jegsl.jpg" style="zoom:50%;" />

改造步骤：

1. 添加一个消息队列；
2. IO 线程中产生的新任务添加进消息队列尾部；
3. 渲染主线程会循环地从消息队列头部中读取任务，执行任务。

#### 处理其他进程发送过来的任务

通过使用消息队列，我们实现了线程之间的消息通信。在 Chrome 中，跨进程之间的任务也是频繁发生的，那么如何处理其他进程发送过来的任务？可以参考下图：

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm0e27satbj30wg0n6qau.jpg" style="zoom:50%;" />

从图中可以看出，**渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息**，接收到消息之后，会将这些消息组装成任务发送给渲染主线程。

#### 消息队列中的任务类型

消息队列中有很多内部消息类型，如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析DOM、样式计算、布局计算、CSS 动画等。

以上这些事件都是在主线程中执行的，所以在编写 Web 应用时，还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。

#### 如何安全退出

当页面主线程执行完成之后，Chrome为保证页面主线程能够安全退出，会在页面主线程设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。如果设置了，那么就直接中断当前的所有任务，退出线程。

#### 页面使用单线程的缺点

页面线程所有执行的任务都来自于消息队列。消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。鉴于这个属性，就有如下两个问题需要解决。

##### 问题一是如何处理高优先级的任务。

比如一个典型的场景是监控 DOM 节点的变化情况（节点的插入、修改、删除等动态变化），然后根据这些变化来处理相应的业务逻辑。一个通用的设计的是，利用 JavaScript设计一套监听接口，当变化发生时，渲染引擎同步调用这些接口，这是一个典型的观察者模式。

不过这个模式有个问题，因为 DOM 变化非常频繁，如果每次发生变化的时候，都直接调用相应的 JavaScript 接口，那么这个当前的任务执行时间会被拉长，从而导致执行效率的下降。

如果将这些 DOM 变化做成异步的消息事件，添加到消息队列的尾部，那么又会影响到监控的实时性，因为在添加到消息队列的过程中，可能前面就有很多任务在排队了。

这也就是说，如果 DOM 发生变化，采用同步通知的方式，会影响当前任务的执行效率；如果采用异步方式，又会影响到监控的实时性。那该如何权衡效率和实时性呢？

针对这种情况，微任务就应用而生了，那微任务是如何权衡效率和实时性的？通常我们把**消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列**，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。

等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。

##### 问题二是如何解决单个任务执行时长过久的问题。

因为所有的任务都是在单线程中执行的，所以每次只能执行一个任务，而其他任务就都处于等待状态。如果其中一个任务执行时间过久，那么下一个任务就要等待很长时间。可以参考下图：

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm0esmbr9xj30ta0b8q5z.jpg" style="zoom:50%;" />

从图中你可以看到，如果在执行动画过程中，其中有个 JavaScript 任务因执行时间过久，占用了动画单帧的时间，这样会给用户制造了卡顿的感觉，这当然是极不好的用户体验。针对这种情况，JavaScript 可以通过**回调功能**来规避这种问题，也就是让要执行的JavaScript 任务滞后执行。

#### 浏览器页面是如何运行的

可以打开开发者工具，点击“Performance”标签，选择左上角的“start porfiling andload page”来记录整个页面加载过程中的事件执行情况，如下图所示：

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm0exa99vdj315i0pownq.jpg" style="zoom:50%;" />

从图中可以看出，我们点击展开了 Main 这个项目，其记录了主线程执行过程中的所有任务。图中灰色的就是一个个任务，每个任务下面还有子任务，其中的 Parse HTML 任务，是把 HTML 解析为 DOM 的任务。值得注意的是，在执行 Parse HTML 的时候，如果遇到JavaScript 脚本，那么会暂停当前的 HTML 解析而去执行 JavaScript 脚本。


## WebAPI：setTimeout

> setTimeout是如何实现的？

浏览器页面是由消息队列和事件循环系统来驱动的。

 `setTimeout` 是一个**定时器，用来指定某个函数在多少毫秒之后执行**。它会返回一个整数，表示定时器的编号，同时你还可以通过该编号来取消这个定时器。下面的示例代码就演示了定时器最基础的使用方式：

```js
function showName() {
  console.log("ramona");
}
var timerID = setTimeout(showName, 200);
```

执行上述代码，通过 setTimeout 指定在 200 毫秒之后调用showName 函数，并输出ramona。

