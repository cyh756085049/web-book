### 面向对象

> 1、创建对象的方法
>
> 2、类的定义、声明
>
> 3、实现继承的方式
>
> 4、原型和原型链
>
> 5、new 运算符

![截屏2020-09-0310.21.18](https://tva1.sinaimg.cn/large/007S8ZIlly1gid8zswdcrj30u00uhn5o.jpg)

### 创建对象的方法

#### 1、字面量

```js
// 字面量创建
var obj = {name: 'ramona'};
// 内置函数创建
var obj = new Object('ramona');
```

#### 2、通过构造函数

```js
var Obj = function(name) {
  this.name = name;
}
var obj = new Obj('ramona');
```

#### 3、Object.create

```js
var obj = {name: 'ramona'};
var p = Object.create(obj);
// 通过原型链创建，p是实例，obj是p的原型。
```

### 原型对象和原型链 

#### 原型对象

1、js的所有对象都包含了一个`__proto__`内部属性。这个属性所对应的就是该对象的原型。

2、js的函数对象除了上面的属性外，还包含了prototype属性，但是实例不包含prototype属性。

3、当函数对象作为构造函数创建实例时，该prptotype属性值将被作为实例对象的原型`__prpto__`。

```js
function Person() {}
var person = new Person();
Person.prototype = person.__proto__;
```

#### 原型链

**原型链的基本原理**：任何一个**实例**，通过原型链，找到它上面的**原型**，该原型对象中的方法和属性，可以被所有的原型实例共享。

Object是原型链的顶端。

原型可以起到继承的作用。原型里的方法都可以被不同的实例共享：

```js
//给Foo的原型添加 say 函数
    Foo.prototype.say = function () {
        console.log('');
    }
```

**原型链的关键**：在访问一个实例的时候，如果实例本身没找到此方法或属性，就往原型上找。如果还是找不到，继续往上一级的原型上找。

> 函数才有 prototype，实例对象只有有**proto**， 而函数有的**proto**是因为函数是 Function 的实例对象

### 原型、构造函数、实例的关系

> 构造函数：任何一个函数，如果前面加了new，则是构造函数

1、**构造函数通过new生成实例**。

2、构造函数也是函数，**构造函数的prototype指向原型**。所有的函数都有prototype属性，但是实例没有prototype属性。

3、**原型对象中有constructor，指向该原型的构造函数**

```js
var Foo = function(name) {
  this.name = name;
}
var foo = new Foo('ramona');
Foo.prototype.constructor === Foo;  // true
```

4、实例的`__proto__`指向原型。也就是，`foo.__proto__ === Foo.prototype`。

声明：所有的**引用类型**（数组、对象、函数）都有`__proto__`这个属性。

`Foo.__proto__ === Function.prototype`的结果为true，说明Foo这个普通的函数，是Function构造函数的一个实例。

###  类的定义、声明

```js
// 构造函数模拟类
function Person() {
  this.name = "ramona";
}
// 用class声明
class  Person() {
  constructor() { // 可以在构造函数里写属性
    this.name = name;
  }
}
```

类的实例化：

```js
new Person();
```

### 继承的方式（本质是原型链）

#### 1、借助构造函数

```js
function Parent() {
  this.name = 'parent 属性';
}

function Child() {
  Parent.call(this);
  this.type = 'child 属性';
}

console.log(new Child());
// Child {name: "parent 属性", type: "child 属性"}
```

`Parent.call(this)`函数， **让Parent的构造函数在child的构造函数中执行**。发生的变化是：**改变this的指向**，parent的实例 --> 改为指向child的实例。导致 parent的实例的属性挂在到了child的实例上，这就实现了继承。

存在的问题：子类不能继承父类的原型。也就是：

```js
Parent.prototype.say = function() {}
console.log(new Child().say());  // 无法获取到Parent原型的内容
```

#### 2、通过原型实现继承

```js
function Parent() {
  this.name = 'Parent 属性';
}

function Child() {
  this.name = 'Child 属性';
}

Child.prototype = new Parent();
console.log(new Child());
```

把parent的实例赋值给child的prototype，实现继承。

```js
new Child().__proto__ === new Parent(); // true
```

存在的问题：child可以继承parent的原型，但如如果创建两个实例，会导致修改一个实例的属性，另一个实例也跟随改变。

#### 3、组合：构造函数 + 原型链

```js
function Parent() {
  this.name = 'Parent 属性';
}

function Child() {
  Parent.call(this);
  this.name = 'Child 属性';
}

Child.prototype = new Parent();
cosole.log(new Child());
```

存在的问题：虽然解决了上述遇到的问题，但是会让Parent的构造方法执行两次。

#### 4、组合2：构造函数 + 原型链 + Object.create()

```js
function Parent() {
  this.name = 'Parent 属性';
}

function Child() {
  Parent.call(this);
  this.name = 'Child 属性';
}
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;
```

Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的**proto**

#### 封装一个原生的继承方法

```js
function extendsClass(Parent, Child) {
  function F() {}
  F.prototype = Parent.prototype;
  Child.prototype = new F();
  Child.protptype.constructor = Child;
  return Child;
}
```

#### ES5/ES6 的继承除了写法以外还有什么区别？

- class 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量。
- class 声明内部会启用严格模式。
- class 的所有方法（包括静态方法和实例方法）都是不可枚举的。
- class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用。
- 必须使用 new 调用 class。
- class 内部无法重写类名。

### `instanceof`的原理

[![img](https://camo.githubusercontent.com/9996f26d7a4e9df5ab87a962689d42de99943855/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303330365f323230392e706e67)](https://camo.githubusercontent.com/9996f26d7a4e9df5ab87a962689d42de99943855/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303330365f323230392e706e67)

`instanceof`的**作用**：用于判断**实例**属于哪个**构造函数**。

`instanceof`的**原理**：判断实例对象的`__proto__`属性，和构造函数的`prototype`属性，是否为同一个引用（是否指向同一个地址）。

**注意1**：虽然说，实例是由构造函数 new 出来的，但是实例的`__proto__`属性引用的是构造函数的`prototype`。也就是说，实例的`__proto__`属性与构造函数本身无关。

**注意2**：在原型链上，原型的上面可能还会有原型，以此类推往上走，继续找`__proto__`属性。这条链上如果能找到， instanceof 的返回结果也是 true。

比如说：

- `foo instance of Foo`的结果为true，因为`foo.__proto__ === Foo.prototype`为true。
- **`foo instance of Objecet`的结果也为true**，因为`Foo.prototype.__proto__ === Object.prototype`为true。

但我们不能轻易的说：`foo 一定是 由Object创建的实例`。这句话是错误的。我们来看下一个问题就明白了。

#### 判断对象是哪个类的直接实例

> 使用`对象.construcor`直接可判断

**问题：已知A继承了B，B继承了C。怎么判断 a 是由A直接生成**的实例，还是B直接生成的实例呢？还是C直接生成的实例呢？

分析：这就要用到原型的`constructor`属性了。

- `foo.__proto__.constructor === Foo`的结果为true，但是 `foo.__proto__.constructor === Object`的结果为false。

所以，**用 consturctor判断就比用 instanceof判断，更为严谨**。

### new运算符

```js
var obj = {};
obj.__proto__ = Obj.prototype;
Obj.call(obj);
```

> 1、创建一个空对象实例。
>
> 2、将此空对象的隐式原型指向构造函数的显示原型。
>
> 3、执行构造函数，同时this指向这个新实例。
>
> 4、如果返回值是一个新对象，那么直接返回对象，如果无返回值或者返回一个非对象值，则把步骤1创建的对象返回。

























